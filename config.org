# C-c ' (org-edit-special) toggles org-edit-src-code on src blocks.
# Reload config with M-x reload-config.

* Defaults
** Turn off alarms completely

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Answering 'y' or 'n'

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable all backups

That's what git is for.

#+BEGIN_SRC emacs-lisp
(setq-default  auto-save-default nil
               create-lockfiles nil
               history-length 500
               make-backup-files nil)
#+END_SRC

** Kill current buffer rather than bringing up list

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

** Don't ask for confirmation when opening symlinked file

#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t )
#+END_SRC

** Warn when opening large files

Warn when opening files bigger than 100MB.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC

** Use Utf-8 encoding

#+BEGIN_SRC emacs-lisp
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
(prefer-coding-system        'utf-8)
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-selection-coding-system 'utf-8)
(setq locale-coding-system   'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
#+END_SRC

** Smooth scrolling

Make scrolling in buffers less jumpy.

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
    scroll-conservatively 100000
    scroll-preserve-screen-position 1)
#+END_SRC

** Display Help in same window

#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist
       '("*Help*" display-buffer-same-window))
#+END_SRC

** Disable all arrow keys

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "<left>"))
(global-unset-key (kbd "<right>"))
(global-unset-key (kbd "<up>"))
(global-unset-key (kbd "<down>"))
(global-unset-key (kbd "<C-left>"))
(global-unset-key (kbd "<C-right>"))
(global-unset-key (kbd "<C-up>"))
(global-unset-key (kbd "<C-down>"))
(global-unset-key (kbd "<M-left>"))
(global-unset-key (kbd "<M-right>"))
(global-unset-key (kbd "<M-up>"))
(global-unset-key (kbd "<M-down>"))
#+END_SRC

** Super save

[[https://github.com/bbatsov/super-save][Super-save]] auto-saves your buffers, when certain events happen - e.g. you
switch between buffers, an Emacs frame loses focus, etc.

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :ensure t
  :diminish super-save-mode
  :config
  (super-save-mode t)
  (setq save-silently t))
#+END_SRC

** Reloading config

Function for reloading config.

#+BEGIN_SRC emacs-lisp
(defun reload-config ()
  (interactive)
    (save-buffer)
    (load-file  "~/.emacs.d/init.el"))
#+END_SRC

** Switch window focus on split

Switch window focus on split.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 2")
                (lambda () (interactive)(split-window-below) (other-window 1)))
(global-set-key (kbd "C-x 3")
                (lambda () (interactive)(split-window-right) (other-window 1)))
#+END_SRC

** Dired
*** Dired auto-revert

Ensures Dired file lists are refreshed when files are created/deleted/renamed.
Also hides auto revert message.

#+BEGIN_SRC emacs-lisp
(setq dired-auto-revert-buffer t)
#+END_SRC

*** Dired hide details by default

#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+END_SRC

*** Enable find alternate file

Bind return to alternate file, so that dired reuses same buffer.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :config
  (put 'dired-find-alternate-file 'disabled nil)
  :bind (:map dired-mode-map
              ("RET" . dired-find-alternate-file)))
#+END_SRC

*** WDired

WDired (writable dired) can be accessed by making the dired buffer writable with the binding C-x C-q. Any change you make to the buffer will remain unchanged until you commit them by typing C-c C-c. To cancel the changes and revert to the original state you can type C-c k.

The feature bellow force confirmation in the case of potential overwrites caused by rename.

#+BEGIN_SRC emacs-lisp
(setq wdired-confirm-overwrite t)
#+END_SRC

** Ask for confirmation when closing emacs

Ask for confirmation when closing emacs.

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

** Show keystrokes ASAP
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
#+END_SRC
** Start emacs server

Open file in existing emacs window (rather than a new session) when clicking on a file in finder.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

** Disable mouse

Disables mouse.

#+BEGIN_SRC emacs-lisp
(use-package disable-mouse
  :ensure t
  :config
  (global-disable-mouse-mode))
#+END_SRC

** Don't ask for confirmation when killing buffers with process

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions nil)
#+END_SRC

* Appearance
** Menu, tool and scroll bars

Hide menu bar.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
#+END_SRC

Hide scroll and tool bar when not in terminal mode.

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (scroll-bar-mode -1)
  (tool-bar-mode -1))
#+END_SRC

** Splash screen

Disables default splash screen.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
    inhibit-startup-message t
    inhibit-startup-echo-area-message t)
#+END_SRC

** Theme
*** Doom

[[doom-spacegrey][Doom]] themes.

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :ensure t
  :defer t)
#+END_SRC

*** Set light/dark themes

Sets light/dark themes, and loads initial theme.

#+BEGIN_SRC emacs-lisp
(setq dark-theme 'doom-spacegrey)
(setq light-theme 'doom-nova)

(setq active-theme dark-theme)

(load-theme active-theme t)
#+END_SRC

*** Toggle light/dark

Function for toggling between light and dark themes.

#+BEGIN_SRC emacs-lisp
(defun toggle-dark-light-theme ()
  (interactive)
  (disable-theme active-theme)
  (if (eq active-theme light-theme)
    (setq active-theme dark-theme)
    (setq active-theme light-theme))
  (load-theme active-theme t))
#+END_SRC

** Modeline

Doom modeline.

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure t
  :hook (after-init . doom-modeline-mode)
  :init
  (setq doom-modeline-icon nil)
  :config
  (doom-modeline-def-segment buffer-info-ignore-modified
    (let ((active (doom-modeline--active)))
      (concat
       (propertize " " 'face (if active 'mode-line 'mode-line-inactive))

       ;; buffer file name
       (when-let ((name (buffer-name)))
         (if active
             (propertize name 'face 'doom-modeline-buffer-file)
           (propertize name 'face 'mode-line-inactive))))))

  (doom-modeline-def-modeline 'my-simple-line
    '(bar buffer-info-ignore-modified checker)
    '())

  (defun setup-custom-doom-modeline ()
    (doom-modeline-set-modeline 'my-simple-line 'default))
  (add-hook 'doom-modeline-mode-hook 'setup-custom-doom-modeline))
#+END_SRC

** Title bar

Title bar matches theme.

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist
             '(ns-transparent-titlebar . t))
(add-to-list 'default-frame-alist
             '(ns-appearance . dark))
#+END_SRC

Remove title bar icon and file name.

#+BEGIN_SRC emacs-lisp
(setq ns-use-proxy-icon nil)
(setq frame-title-format nil)
#+END_SRC

** Initial frame
*** Size

Sets the initial frame to fill the screen.

#+BEGIN_SRC emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+END_SRC

*** Position

Sets the initial frame to be flush with the top left corner of the screen.

#+BEGIN_SRC emacs-lisp
(add-to-list 'initial-frame-alist '(left . 0))
(add-to-list 'initial-frame-alist '(top . 0))
#+END_SRC
** Cursor shape

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

** Remove cursor only appears in current buffer

#+BEGIN_SRC emacs-lisp
(setq-default cursor-in-non-selected-windows nil)
#+END_SRC

** Font

Sets font and font size.

#+BEGIN_SRC emacs-lisp
(set-default-font "Menlo 14")
#+END_SRC

** Enable visual line mode

#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
#+END_SRC

* Text Manipulation
** Delete selected region when typing

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Only use spaces

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Tab width

Set tab width.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

** Contextual tab

Tab will now contextually indent or complete.

#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
#+END_SRC

** Flyspell

Turn spellcheck on, sets it to use aspell and british spelling.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :config
  (setq ispell-program-name "aspell"
    ispell-extra-args '("--sug-mode=ultra" "--lang=en_GB"))
  (setq flyspell-prog-text-faces
        ;; disables spellcheck in strings for prog mode (still works in comments)
        (delq 'font-lock-string-face
              flyspell-prog-text-faces))
  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode))
#+END_SRC

** Undo tree

[[https://www.emacswiki.org/emacs/UndoTree][Undo-tree]] enables conventional undo-redo behaviour.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :bind (("s-Z" . undo-tree-redo)
     ("s-z" . undo-tree-undo))
  :config
  (setq undo-tree-history-directory-alist
    `((".*" . ,temporary-file-directory)))
  (setq undo-tree-auto-save-history t))
#+END_SRC

** White space

[[https://www.emacswiki.org/emacs/WhiteSpace][whitespace]] cleans white space on save.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :init
  (add-hook 'before-save-hook #'whitespace-cleanup))
#+END_SRC

** Sentence should end with only a full stop

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

** Back to indentation or beginning

#+BEGIN_SRC emacs-lisp
(defun back-to-indentation-or-beginning () (interactive)
   (if (= (point) (progn (back-to-indentation) (point)))
       (beginning-of-line)))

(global-set-key (kbd "C-a") 'back-to-indentation-or-beginning)
#+END_SRC

** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] on-the-fly syntax checking extension.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init
  (global-flycheck-mode)
  ;; Change fringe indicator to be a circle
  (define-fringe-bitmap 'my-flycheck-fringe-indicator
    (vector #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b11111111
            #b11111111
            #b11111111
            #b11111111
            #b11111111
            #b11111111
            #b11111111
            #b11111111
            #b00000000
            #b00000000
            #b00000000
            #b00000000
            #b00000000))
  (flycheck-define-error-level 'error
    :severity 2
    :overlay-category 'flycheck-error-overlay
    :fringe-bitmap 'my-flycheck-fringe-indicator
    :fringe-face 'flycheck-fringe-error)
  (flycheck-define-error-level 'warning
    :severity 1
    :overlay-category 'flycheck-warning-overlay
    :fringe-bitmap 'my-flycheck-fringe-indicator
    :fringe-face 'flycheck-fringe-warning)
  (flycheck-define-error-level 'info
    :severity 0
    :overlay-category 'flycheck-info-overlay
    :fringe-bitmap 'my-flycheck-fringe-indicator
    :fringe-face 'flycheck-fringe-info))
#+END_SRC

* Navigation
** Recent files

[[https://www.emacswiki.org/emacs/RecentFiles][Recentf]] is a minor mode that builds a list of recently opened files.

#+BEGIN_SRC emacs-lisp
(recentf-mode t)
#+END_SRC

** Ivy

[[https://github.com/abo-abo/swiper][Ivy]] a light weight fuzzy search completion framework.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
       :ensure t
       :diminish ivy-mode
       :config
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       :init
       (ivy-mode t))
#+END_SRC

** Swiper

[[https://github.com/abo-abo/swiper][Swiper]] an Ivy-enhanced alternative to isearch.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind ("C-s" . swiper)
    ("s-f" . swiper))
#+END_SRC

** Counsel

[[https://github.com/abo-abo/swiper][Counsel]] provides versions of common Emacs commands that are customised to make the best use of ivy.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :init
  (counsel-mode t)
  :bind
  ("C-x p" . counsel-git)
  ("C-S-s" . counsel-git-grep))
#+END_SRC

* Project Management
** Magit

[[https://magit.vc/][Magit]] is a great interface for git projects.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :defer t
  :config
  (setq magit-completing-read-function 'ivy-completing-read)
  (setq magit-save-repository-buffers 'dontask)
  :bind ("C-x g" . magit-status))
#+END_SRC

*** Fullscreen magit

The following code makes magit-status run alone in the frame, and then
restores the old window configuration when you quit out of magit.

#+BEGIN_SRC emacs-lisp
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+END_SRC

** Org mode

*** Defer Org

Defer org to speed up load time (if config hasn't changed).

#+BEGIN_SRC emacs-lisp
(use-package org
    :defer t)
#+END_SRC

*** Org babel/source blocks
Enables source blocks syntax highlights and makes the editing popup
window stay within the same window.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-window-setup 'current-window
      org-src-strip-leading-and-trailing-blank-lines t
      org-src-preserve-indentation t
      org-src-tab-acts-natively t)
#+END_SRC

* Programming
** General
*** Show line numbers

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+END_SRC

*** Company mode

[[https://github.com/company-mode/company-mode][Company]] is a text completion framework for Emacs. The name stands
for "complete anything". It uses pluggable back-ends and front-ends
to retrieve and display completion candidates.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :init
    (setq company-idle-delay 0.2)
    (global-company-mode)
  :bind (:map company-active-map
              ("C-n" . company-select-next)
              ("C-p" . company-select-previous)
              ("TAB" . company-complete-selection)))
#+END_SRC

*** Compilation buffers display ANSI

#+BEGIN_SRC emacs-lisp
(use-package ansi-color
  :ensure t
  :config (progn
            (defun ansi-colorize-buffer ()
              (let ((inhibit-read-only t))
                (ansi-color-apply-on-region (point-min) (point-max))))
            (add-hook 'compilation-filter-hook 'ansi-colorize-buffer)))
#+END_SRC

*** Aggressive Indent

[[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent]] automatically keeps things indented.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :init
  (add-hook 'prog-mode-hook 'aggressive-indent-mode))
#+END_SRC

*** Smartparens

[[https://github.com/Fuco1/smartparens][Smartparens]] paredit for all the things.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config
  (progn
    (use-package smartparens-config)
    (sp-use-smartparens-bindings)
    (show-smartparens-global-mode t)
    (setq sp-highlight-pair-overlay nil))
  :init
  (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
  (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)
  :bind (:map smartparens-mode-map
              ("C-(" . sp-backward-slurp-sexp)
              ("C-{" . sp-backward-barf-sexp)
              ("C-)" . sp-forward-slurp-sexp)
              ("C-}" . sp-forward-barf-sexp)))
#+END_SRC

** Clojure
*** Edn

[[https://github.com/expez/edn.el][Edn]] is an emacs lisp library for reading and writing the data format edn.

#+BEGIN_SRC emacs-lisp
(use-package edn
  :ensure t)
#+END_SRC

*** Clojure Mode & Inferior Lisp

#+BEGIN_SRC emacs-lisp
(setq inferior-lisp-program "lein update-in :dependencies conj [compliment\"0.3.8\"] -- repl")

(defun clj-eval (edn)
  (-> (edn-print-string edn)
      lisp-eval-string))

(defun clj-symbol-at-point ()
    (with-syntax-table clojure-mode-syntax-table
      (symbol-at-point)))

(defun enable-repl-pprint ()
  (clj-eval '(clojure.main/repl :print (fn [x] (newline)
                                           (clojure.pprint/pprint x)))))

(defun on-first-prompt (output)
  (when (string-match "^[^=>]*[=>] *" output)
    (enable-repl-pprint)
    (remove-hook 'comint-output-filter-functions
                 'on-first-prompt)))

(defun clj-open-repl ()
  (interactive)
  (add-hook 'comint-output-filter-functions
            'on-first-prompt)
  (if (one-window-p)
      (progn (split-window-right)
             (other-window 1)
             (inferior-lisp inferior-lisp-program))
    (progn (inferior-lisp inferior-lisp-program)
           (switch-to-prev-buffer)
           (other-window 1)
           (inferior-lisp inferior-lisp-program)))
  (comint-show-maximum-output)
  (other-window 1))

(defun kill-inferior-lisp-buffer ()
  (when (get-buffer "*inferior-lisp*")
    (kill-buffer "*inferior-lisp*")))

(defun start-repl (repl-command-string)
  (kill-inferior-lisp-buffer)
  (setq inferior-lisp-program repl-command-string)
  (clj-open-repl))

;; Need to omit spaces in arg string as inf-lisp just does a split on string:
;; https://github.com/emacs-mirror/emacs/blob/d0e2a341dd9a9a365fd311748df024ecb25b70ec/lisp/progmodes/inf-lisp.el#L306p
(defun clj-repl ()
  (interactive)
  (start-repl "clojure -Sdeps {:deps{compliment{:mvn/version\"0.3.8\"}}}"))
(defun lein-repl ()
  (interactive)
  (start-repl "lein update-in :dependencies conj [compliment\"0.3.8\"] -- repl"))
(defun heroku-repl ()
  (interactive)
  (start-repl "heroku run lein repl"))
(defun heroku-production-repl ()
  (interactive)
  (start-repl "heroku run lein repl --remote production"))
(defun heroku-staging-repl ()
  (interactive)
  (start-repl "heroku run lein repl --remote staging"))

(defun clj-doc-for-symbol ()
  (interactive)
  (clj-eval `(clojure.repl/doc ,(clj-symbol-at-point))))

(defun clj-source-for-symbol ()
  (interactive)
  (clj-eval `(clojure.repl/source ,(clj-symbol-at-point))))

(defun clj-javadoc-for-symbol ()
  (interactive)
  (clj-eval `(clojure.java.javadoc/javadoc ,(clj-symbol-at-point))))

(defun clj-apply-f-to-ns-and-return-to-point (f)
  (save-buffer)
  (let ((current-point (point)))
    (goto-char (point-min))
    (let ((ns-idx (re-search-forward clojure-namespace-name-regex nil t)))
      (when ns-idx
        (goto-char ns-idx)
        (let ((sym (clj-symbol-at-point)))
          (funcall f sym))))
    (goto-char current-point)))

(defun clj-load-current-ns ()
  (interactive)
  (clj-apply-f-to-ns-and-return-to-point
   (lambda (sym)
     (clj-eval `(do (require ',sym :reload)
                    (in-ns ',sym))))))

(defun clj-eval-buffer ()
  (interactive)
  (lisp-eval-region (point-min) (point-max)))

(defun clj-run-test-for-current-ns ()
  (interactive)
  (clj-apply-f-to-ns-and-return-to-point
   (lambda (sym)
     (let* ((sym-name (symbol-name sym))
            (ns (make-symbol
                 (if (string-suffix-p "test" sym-name)
                     (replace-regexp-in-string "-test" "" sym-name)
                   sym-name)))
            (test-ns (make-symbol
                      (if (string-suffix-p "test" sym-name)
                          sym-name
                        (concat sym-name "-test")))))
       (clj-eval `(do (require ',ns :reload)
                      (require ',test-ns :reload)
                      (clojure.test/run-tests ',test-ns)))))))

(defun clj-comment-form ()
  (interactive)
  (let ((bounds (bounds-of-thing-at-point 'sexp)))
    (if bounds
        (progn (goto-char (car bounds))
               (search-backward "\"" (- (point) 1) t))
      (clojure-backward-logical-sexp))
    (if (search-forward "#_" (+ (point) 2) t)
        (delete-char -2)
      (insert "#_")
      (backward-char 2))))

(defun clj-apropos ()
  (interactive)
  (->> (read-string "Apropos (regex):")
       (format "(clojure.repl/apropos #\"%s\")")
       lisp-eval-string))

(defun clj-find-doc ()
  (interactive)
  (->> (read-string "Find Doc (regex):")
       (format "(clojure.repl/find-doc #\"%s\")")
       lisp-eval-string))

(defun clj-find-implementation-or-test (file-name)
  (unless file-name (error "The current buffer is not visiting a file"))
  (if (string-suffix-p "test" (file-name-sans-extension
                               (file-name-nondirectory file-name)))
      (replace-regexp-in-string
       "_test" "" (replace-regexp-in-string
                   "test/" "src/" file-name))
    (replace-regexp-in-string
     "src/" "test/" (replace-regexp-in-string ".clj" "_test.clj" file-name))))

(defun clj-toggle-between-implementation-and-test ()
  (interactive)
  (-> (buffer-file-name)
      clj-find-implementation-or-test
      find-file))

(defun clj-compliment-completion ()
  (interactive)
  (clj-eval
   `(do (require '[compliment.core])
        (compliment.core/completions ,(symbol-name (clj-symbol-at-point))))))

(use-package clojure-mode
  :ensure t
  :defer t
  :bind (:map clojure-mode-map
              ("C-c C-a" . clj-apropos)
              ("C-c C-z" . clj-open-repl)
              ("C-c C-d" . clj-doc-for-symbol)
              ("C-c C-s" . clj-source-for-symbol)
              ("C-c C-j" . clj-javadoc-for-symbol)
              ("C-c C-f" . clj-find-doc)
              ("C-c C-l" . clj-load-current-ns)
              ("C-c C-b" . clj-eval-buffer)
              ("M-g t"   . clj-toggle-between-implementation-and-test)
              ("C-c C-t" . clj-run-test-for-current-ns)
              ("C-x C-e" . lisp-eval-last-sexp)
              ("M-;"     . clj-comment-form)))

(add-hook 'inferior-lisp-mode-hook (lambda()
                                     (font-lock-add-keywords 'inferior-lisp-mode
                                                             clojure-font-lock-keywords 'end)))

(defun empty-file ()
  (save-excursion
    (save-match-data
      (goto-char (point-min))
      (eobp))))

(defun clj-insert-ns-form-when-opening-clj-file ()
  (when (empty-file)
    (clojure-insert-ns-form)))

(defun clj-before-save ()
  (when (eq major-mode 'clojure-mode)
    (clojure-align (point-min) (point-max))))

(add-hook 'clojure-mode-hook 'clj-insert-ns-form-when-opening-clj-file)
(add-hook 'before-save-hook 'clj-before-save)
#+END_SRC

*** Flycheck Joker

[[https://github.com/candid82/flycheck-joker][flycheck-joker]] is a clojure linter.

#+BEGIN_SRC emacs-lisp
(use-package flycheck-joker
  :ensure t)
#+END_SRC

** Http

[[https://github.com/pashky/restclient.el][restclient]] a tool for manually exploring and testing HTTP REST webservices.

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t
  :defer t
  :mode ("\\.\\(http\\|rest\\)$" . restclient-mode))
#+END_SRC
* Misc
** Epub Reader

[[https://github.com/wasamasa/nov.el][nov.el]] an epub reader for emacs.

#+BEGIN_SRC emacs-lisp
(use-package nov
  :ensure t
  :defer t
  :config
  (setq nov-variable-pitch nil))
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
#+END_SRC

** Music

[[https://www.gnu.org/software/emms/][emms]] music player.

#+BEGIN_SRC emacs-lisp
(use-package emms
  :ensure t
  :defer t
  :config
  (emms-standard)
  (emms-default-players)
  (emms-mode-line-disable)
  (setq emms-repeat-playlist t)
  (setq emms-source-file-default-directory "~/Documents/music"))
#+END_SRC

** Markdown Mode

[[https://github.com/jrblevin/markdown-mode][Markdown mode]] for rendering markdown.

#+BEGIN_SRC emacs-lisp
(defun clj-open-md-block-repl ()
  (interactive)
  (setq inferior-lisp-program
        "clojure -Sdeps {:deps{compliment{:mvn/version\"0.3.8\"}}}")
  (clj-open-repl))

(use-package markdown-mode
  :ensure t
  :defer t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown")
  :config (markdown-toggle-fontify-code-blocks-natively)
  :bind (:map markdown-mode-map
              ("C-c C-a" . clj-apropos)
              ("C-c C-z" . clj-open-md-block-repl)
              ("C-c C-d" . clj-doc-for-symbol)
              ("C-c C-s" . clj-source-for-symbol)
              ("C-c C-f" . clj-find-doc)
              ("C-x C-e" . lisp-eval-last-sexp)))
#+END_SRC
