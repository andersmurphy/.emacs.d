* Installing Emacs
** OSX

Install emacs using homebrew.

#+BEGIN_SRC sh
brew install emacs --with-cocoa
#+END_SRC

Symlink Emacs.app to application folder (isn't supported by spotlight).

#+BEGIN_SRC sh
brew linkapps emacs
#+END_SRC

Remove the symlink.

#+BEGIN_SRC sh
rm /Applications/Emacs.app
#+END_SRC

Create an alias for emacs and move it to the application folder, this is supported
by spotlight.

#+BEGIN_SRC sh
osascript -e 'tell application "Finder" to make alias file to POSIX file "/usr/local/opt/emacs/Emacs.app" at POSIX file "/Applications"'
#+END_SRC

* External Dependencies
** The Silver Searcher

The search functionality of some packages (dumb-jump and projectile) depends
on the silver search for speed.

#+BEGIN_SRC sh
brew install the_silver_searcher
#+END_SRC

** Aspell

Spellcheck depends on aspell.

#+BEGIN_SRC sh
brew install aspell
#+END_SRC

* Defaults
** Turn off alarms completly

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Answering 'y' or 'n'

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Keep all backup and auto-save files in one directory

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

** Kill current buffer rather than bringing up list

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

** Warn when opening large files

Warn when opening files bigger than 100MB.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC

** Mode line settings

Add line and column number as well as file size to mode line.

#+BEGIN_SRC emacs-lisp
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC

** Use Utf-8 encoding

#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

** Smooth scrolling

Make scrolling in buffers less jumpy.

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
    scroll-conservatively 100000
    scroll-preserve-screen-position 1)
#+END_SRC

** Truncate lines

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

** Display Help in same window

#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist
       '("*Help*" display-buffer-same-window))
#+END_SRC

** Disable all arrow keys

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "<left>"))
(global-unset-key (kbd "<right>"))
(global-unset-key (kbd "<up>"))
(global-unset-key (kbd "<down>"))
(global-unset-key (kbd "<C-left>"))
(global-unset-key (kbd "<C-right>"))
(global-unset-key (kbd "<C-up>"))
(global-unset-key (kbd "<C-down>"))
(global-unset-key (kbd "<M-left>"))
(global-unset-key (kbd "<M-right>"))
(global-unset-key (kbd "<M-up>"))
(global-unset-key (kbd "<M-down>"))
#+END_SRC

** Super save

[[https://github.com/bbatsov/super-save][Super-save]] auto-saves your buffers, when certain events happen - e.g. you
switch between buffers, an Emacs frame loses focus, etc.

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :ensure t
  :diminish super-save-mode
  :config
  (super-save-mode t))
#+END_SRC

* Appearance
** Menu, tool and scroll bars

Hide menu bar.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
#+END_SRC

Hide scroll and tool bar when not in terminal mode.

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (scroll-bar-mode -1)
  (tool-bar-mode -1))
#+END_SRC

** Splash screen

Disables default splash screen.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
    inhibit-startup-message t
    inhibit-startup-echo-area-message t)
#+END_SRC

** Theme
*** Spacemacs

[[https://github.com/nashamri/spacemacs-theme][Spacemacs-theme]] is a nice theme with both light/dark variants.

#+BEGIN_SRC emacs-lisp
(use-package spacemacs-theme
  :ensure t
  :defer t)
#+END_SRC

*** Set light/dark themes

Sets light/dark themes, and loads initial theme.

#+BEGIN_SRC emacs-lisp
(setq dark-theme 'spacemacs-dark)
(setq light-theme 'spacemacs-light)

(setq active-theme dark-theme)

(load-theme active-theme t)
#+END_SRC

*** Toggle light/dark

Function for toggling between light and dark themes.

#+BEGIN_SRC emacs-lisp

(defun toggle-dark-light-theme ()
  (interactive)
  (disable-theme active-theme)
  (if (eq active-theme light-theme)
    (setq active-theme dark-theme)
    (setq active-theme light-theme))
  (load-theme active-theme t))
#+END_SRC

** Initial frame
*** Size

Sets the initial frame to fill the height of the screen.

#+BEGIN_SRC emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . fullheight))
#+END_SRC

*** Position

Sets the initial frame to be flush with the top left corner of the screen.

#+BEGIN_SRC emasc-lisp
(add-to-list 'initial-frame-alist '(left . 0))
(add-to-list 'initial-frame-alist '(top . 0))
#+END_SRC
* Hydras
** Hail Hydra

Hail Hydra, a hydra for managing other hydras.

#+BEGIN_SRC emacs-lisp
(defhydra hail-hydra (:foreign-keys warn :columns 3)
  "Hail Hydra"
  ("b" hydra-buffer/body "buffer" :exit t)
  ("c" hydra-config/body "config" :exit t)
  ("f" hydra-file/body "file" :exit t)
  ("g" hydra-git/body "git" :exit t)
  ("h" hydra-help/body "help" :exit t)
  ("j" avy-goto-word-1 "avy jump" :exit t)
  ("p" hydra-project/body "project" :exit t)
  ("r" hydra-region/body "region" :exit t)
  ("s" hydra-snippet/body "snippet" :exit t)
  ("t" toggle-shell "terminal" :exit t)
  ("w" hydra-window/body "window" :exit t)
  ("+" toggle-dark-light-theme "light/dark" :exit t)
  ("<SPC>" execute-extended-command "execute command" :exit t)
  ("q" nil "quit")
)
#+END_SRC

** Buffer hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffer (:foreign-keys warn :columns 2)
  "Buffer"
  ("s" ivy-switch-buffer "switch" :exit t)
  ("n" next-buffer "next")
  ("p" previous-buffer "previous")
  ("k" kill-this-buffer "kill" :exit t)
  ("q" nil "quit")
)
#+END_SRC

** Config hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-config (:foreign-keys warn :columns 3)
  "Config"
  ("o" (find-file  "~/.emacs.d/config.org") "open emacs config" :exit t)
  ("r" (load-file  "~/.emacs.d/init.el") "reload emacs config" :exit t)
  ("q" nil "quit")
)
#+END_SRC

** File hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-file (:foreign-keys warn :columns 2)
  "File"
  ("o" find-file "open file" :exit t)
  ("D" vc-delete-file "delete file" :exit t)
  ("r" ivy-switch-buffer "recent file" :exit t)
  ("s" swiper "search file" :exit t)
  ("q" nil "quit")
)
#+END_SRC

** Git hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-git (:foreign-keys warn :columns 3)
  "Git"
  ("s" magit-status "status" :exit t)
  ("b" magit-blame "blame" :exit t)
  ("q" nil "quit")
)
#+END_SRC

** Help hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-help (:foreign-keys warn :columns 2)
  "Help"
  ("f" describe-function "describe function" :exit t)
  ("k" describe-key "describe key" :exit t)
  ("m" describe-mode "describe mode" :exit t)
  ("v" describe-variable "describe variable" :exit t)
  ("q" nil "quit" :exit t)
)
#+END_SRC

** Project hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-project (:foreign-keys warn :columns 2)
  "Project"
  ("a" projectile-discover-projects-in-directory "add projects in directory" :exit t)
  ("b" dumb-jump-back "back from definition")
  ("f" projectile-find-file "find file in project" :exit t)
  ("j" dumb-jump-go "jump to definition")
  ("o" projectile-switch-project "open project" :exit t)
  ("r" projectile-remove-known-project "remove known project" :exit t)
  ("s" projectile-ag "search project")
  ("t" projectile-toggle-between-implementation-and-test  "toggle test/implementation" :exit t)
  ("T" projectile-test-project "runs all tests" :exit t)
  ("q" nil "quit")
)
#+END_SRC

** Region hydra

Contextual hydra if a region is active act on region, if no region is active
act on line.

#+BEGIN_SRC emacs-lisp
(defun duplicate-line-or-region()
  (interactive)
  (call-interactively 'whole-line-or-region-copy-region-as-kill)
  (call-interactively 'whole-line-or-region-yank))

(defun indent-line-or-region (prefix)
       (interactive "*p")
       (whole-line-or-region-call-with-region 'indent-region prefix t))

(defhydra hydra-region (:foreign-keys warn :columns 2)
  "Region"
  ("a" mark-whole-buffer "select all")
  ("c" whole-line-or-region-copy-region-as-kill "copy line/region" :exit t)
  ("d" duplicate-line "duplicate line/region" :exit t)
  ("e" er/expand-region "expand region")
  ("i" indent-line-or-region "indent line/region" :exit t)
  ("j" move-text-down "move line/region down")
  ("k" move-text-up "move line/region up")
  ("s" er/contract-region "shrink region")
  ("x" whole-line-or-region-kill-region "cut line/region" :exit t)
  ("q" nil "quit" :exit t))
#+END_SRC

** Snippet hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-snippet (:foreign-keys warn :columns 2)
  "Snippet"
  ("e" yas-visit-snippet-file "edit snippet" :exit t)
  ("n" open-new-snippet-below "new snippet" :exit t)
  ("s" save-and-close-window  "save snippet" :exit t)
  ("q" nil "quit" :exit t)
)
#+END_SRC

Save and close window.

#+BEGIN_SRC emacs-lisp
(defun save-and-close-window ()
       (interactive)
       (save-buffer)
       (delete-window))
#+END_SRC

** Window hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window (:foreign-keys warn :columns 2)
  "Window"
  ("f" toggle-frame-fullscreen "toggle fullscreen" :exit t)
  ("h" split-window-below "horizontal split" :exit t)
  ("k" delete-window "kill window" :exit t)
  ("s" other-window "switch window")
  ("v" split-window-right "vertical split" :exit t)
  ("q" nil "quit")
)
#+END_SRC

* Evil
** Evil Mode

[[https://github.com/emacs-evil/evil][Evil]] is an extensible vi layer for Emacs. It emulates the main features of Vim.

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t
  :init (evil-mode t))
#+END_SRC

** Evil Escape

[[https://github.com/syl20bnr/evil-escape][Evil ecaspe]] is a customisable key sequence to escape from insert state and
everything else in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package evil-escape
  :ensure t
  :init (evil-escape-mode t))

#+END_SRC

** Evil Tutor

[[https://github.com/syl20bnr/evil-tutor][Evil Tutor]] is a vim tutor adapted for Evil and wrapped in a major mode.

#+BEGIN_SRC emacs-lisp
(use-package evil-tutor
  :ensure t)
#+END_SRC

** Evil Surround

[[https://github.com/timcharper/evil-surround][Evil surround]] adds verb for surrounding things.

#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :ensure t
  :init (global-evil-surround-mode 1))
#+END_SRC

** Evil Magit

[[https://github.com/justbur/evil-magit][Evil Magit]] configures Magit and Evil to play well with each other.

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :ensure t)
#+END_SRC

** Evil Snipe

[[https://github.com/hlissner/evil-snipe][Evil-snipe]] emulates vim-seek and/or vim-sneak in evil-mode.

#+BEGIN_SRC emacs-lisp
(use-package evil-snipe
  :ensure t
  :init (evil-snipe-mode 1))
#+END_SRC

** Leader key

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "SPC") 'hail-hydra/body)
#+END_SRC

** Cursor Colour By State

#+BEGIN_SRC emacs-lisp
(setq evil-normal-state-cursor  '("#EEAD0E" box) ;; orange
      evil-insert-state-cursor '("#66CD00" hbar)) ;; green
#+END_SRC

* Shell
** Exec path from shell

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] makes emacs shell behave like local shell.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
  :ensure t)
#+END_SRC

Sets $MANPATH, $PATH and exec-path from your shell, but only on OS X.
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize))
#+END_SRC

** Toggle Shell
If shell window is open close it otherwise open it.

#+BEGIN_SRC emacs-lisp
(defun toggle-shell ()
   (interactive)
   (if (get-buffer-window "*shell*")
    (delete-window (get-buffer-window "*shell*"))
  (shell)))
#+END_SRC

* Text Manipulation
** Delete selected region when typing

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Only use spaces

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Tab width

Set tab width.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

** Contextual tab

Tab will now contextually indent or complete.

#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
#+END_SRC

** Move Text

[[https://github.com/emacsfodder/move-text][MoveText]] is extracted from Basic edit toolkit. It allows you to move the
current line using M-up / M-down if a region is marked, it will move the
region instead.

#+BEGIN_SRC emacs-lisp
(use-package move-text
  :ensure t)
#+END_SRC

** Flyspell

Turn spellcheck on, sets it to use aspell and british spelling.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :config
  (setq ispell-program-name "aspell"
    ispell-extra-args '("--sug-mode=ultra" "--lang=en_GB"))
  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode))
#+END_SRC

** Expand Region

[[https://github.com/magnars/expand-region.el][Expand-region]]  increases the selected region by semantic units.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
       :ensure t)
#+END_SRC

** Undo tree

[[https://www.emacswiki.org/emacs/UndoTree][Undo-tree]] enables conventional undo-redo behaviour.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :bind (("s-Z" . undo-tree-redo)
     ("s-z" . undo-tree-undo))
  :config
  (setq undo-tree-history-directory-alist
    `((".*" . ,temporary-file-directory)))
  (setq undo-tree-auto-save-history t))
#+END_SRC

** White space

[[https://www.emacswiki.org/emacs/WhiteSpace][whitespace]] cleans white space on save .

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :init
  (add-hook 'before-save-hook #'whitespace-cleanup))
#+END_SRC

** Hungry Delete

[[https://github.com/nflath/hungry-delete][Hungry delete]] deletes all the contiguous whitespace either before point
or after point in a single operation.

#+BEGIN_SRC emacs-lisp
(use-package hungry-delete :ensure t
  :diminish ""
  :config
  (global-hungry-delete-mode))
#+END_SRC

** Whole line or region

[[https://github.com/purcell/whole-line-or-region][Whole line or region]] makes text manipulation act on whole line if region
not active.

#+BEGIN_SRC emacs-lisp
(use-package whole-line-or-region
             :ensure t)
#+END_SRC

* Navigation
** Recent files

[[https://www.emacswiki.org/emacs/RecentFiles][Recentf]] is a minor mode that builds a list of recently opened files.

#+BEGIN_SRC emacs-lisp
(recentf-mode t)
#+END_SRC

** Ivy

[[https://github.com/abo-abo/swiper][Ivy]] a light weight fuzzy search completion framework.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
       :ensure t
       :diminish ivy-mode
       :config
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       :init
       (ivy-mode t))
#+END_SRC

** Swiper

[[https://github.com/abo-abo/swiper][Swiper]] an Ivy-enhanced alternative to isearch.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind ("C-s" . swiper)
    ("s-f" . swiper))
#+END_SRC

** Projectile

[[https://github.com/bbatsov/projectile][Projectile]] is a project interaction library for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package projectile
     :ensure t
     :config
     (setq projectile-completion-system 'ivy)
     :init
     (projectile-global-mode))
#+END_SRC

You can discover projects in a folder with the command:

#+BEGIN_SRC
M-x projectile-discover-projects-in-directory
#+END_SRC

 Add custom project type and test suffix function.

#+BEGIN_SRC emacs-lisp

(projectile-register-project-type 'npm '("package.json" "src" "test") "npm start" "npm test")

(setq projectile-test-suffix-function 'custome-projectile-test-suffix)

(defun custome-projectile-test-suffix (project-type)
  "Find default test files suffix based on PROJECT-TYPE."
  (cond
   ((member project-type '(emacs-cask)) "-test")
   ((member project-type '(rails-rspec ruby-rspec npm)) "_spec")
   ((member project-type '(rails-test ruby-test lein-test boot-clj go elixir)) "_test")
))

#+END_SRC

** Dumb Jump

[[https://github.com/jacktasia/dumb-jump][Dumb Jump]] is an Emacs "jump to definition" package with support for multiple
programming languages that favors "just working". This means minimal -- and
ideally zero -- configuration with absolutely no stored indexes (TAGS) or
persistent background processes.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
   :ensure t
   :config
   (setq dumb-jump-selector 'ivy))
#+END_SRC

** Hydra

[[https://github.com/abo-abo/hydra][Hydra]] is a package that can be used to tie related commands into a family of
short bindings with a common prefix - a Hydra.

#+BEGIN_SRC emacs-lisp
(use-package hydra
       :ensure t)
#+END_SRC

** Ag (Silver Searcher)

[[https://github.com/Wilfred/ag.el][Ag]] allows you to search using ag from inside Emacs. You can filter
by file type, edit results inline, or find files.

#+BEGIN_SRC emacs-lisp
(use-package ag
  :ensure t)
#+END_SRC

** Avy

[[https://github.com/abo-abo/avy][Avy]] is a package for jumping to visible text using a char-based decision tree.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t)
#+END_SRC

* Project Management
** Magit

[[https://magit.vc/][Magit]] is a great interface for git projects.

#+BEGIN_SRC emacs-lisp
  (use-package magit
       :ensure t
       :defer t
       :config
       (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
       (setq magit-completing-read-function 'ivy-completing-read))
#+END_SRC

*** Fullscreen magit

The following code makes magit-status run alone in the frame, and then
restores the old window configuration when you quit out of magit.

#+BEGIN_SRC emacs-lisp
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+END_SRC

** Org mode
*** Org babel/source blocks
Enables source blocks syntax highlights and makes the editing popup
window stay within the same window.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
      org-src-window-setup 'current-window
      org-src-strip-leading-and-trailing-blank-lines t
      org-src-preserve-indentation t
      org-src-tab-acts-natively t)
#+END_SRC

* Programming Languages
** General
*** Show line numbers

#+BEGIN_SRC emacs-lisp
 (add-hook 'prog-mode-hook (lambda () (linum-mode t)))
#+END_SRC

*** Electric pair mode

#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC

*** Show paren mode

Show matching Parens.

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

*** Company mode

[[https://github.com/company-mode/company-mode][Company]] is a text completion framework for Emacs. The name stands
for "complete anything". It uses pluggable back-ends and front-ends
to retrieve and display completion candidates.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (global-company-mode))
#+END_SRC

Get Company to show suggestions for Yasnippet names.

#+BEGIN_SRC emacs-lisp
(defun backend-with-yas (backend)
  (if (and (listp backend) (member 'company-yasnippet backend))
      backend
    (append (if (consp backend) backend (list backend))
            '(:with company-yasnippet))))

(setq company-backends (mapcar #'backend-with-yas company-backends))
#+END_SRC

*** YASnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function templates.

Snippets are stored in the /.emacs.d/snippets/ directory in directories
that match the mode they should be available in.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (setq yas-snippet-dirs (concat user-emacs-directory "snippets"))
  (yas-global-mode))
#+END_SRC

Opens yas-new-snippet in a window below the current one.

#+BEGIN_SRC emacs-lisp
(defun open-new-snippet-below ()
  (interactive)
  (split-window-below)
  (other-window 1)
  (yas-new-snippet))
#+END_SRC

*** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] on-the-fly syntax checking extension.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC

*** Comment/uncomment a line/region

Binds a key to comment/uncomment a line or region if selected.

#+BEGIN_SRC emacs-lisp
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line
   if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
      (setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))

(global-set-key (kbd "s-/") 'comment-or-uncomment-region-or-line)
#+END_SRC

*** Compilation buffers display ANSI

#+BEGIN_SRC emacs-lisp
(ignore-errors
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
  (when (eq major-mode 'compilation-mode)
    (ansi-color-apply-on-region compilation-filter-start (point-max))))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))
#+END_SRC

** Lisps
** Ruby
*** Other files that should be treated as ruby code

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist
     '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
(add-to-list 'auto-mode-alist
     '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))
#+END_SRC

*** Flycheck

Flycheck checks Ruby with ruby-rubocop and ruby-rubylint, falling back to
ruby or ruby-jruby for basic syntax checking if those are not available.

** Javascript
*** Web mode
Handles files that mix html and js like jsx.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (web-mode-use-tabs))
#+END_SRC

*** Other files that should be treated as javascript code

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode))
#+END_SRC

*** Flycheck

Flycheck checks Javascript with one of javascript-eslint, javascript-jshint
or javascript-gjslint, and then with javascript-jscs.

** Json
*** Json mode

[[Major mode for editing JSON file][Json Mode]] is a major mode for editing JSON file.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t)
#+END_SRC

*** Flycheck

Flycheck checks JSON with json-jsonlint or json-python-json.
