* Installing Emacs
** OSX

Install emacs using homebrew.

#+BEGIN_SRC sh
brew install emacs --with-cocoa
#+END_SRC

Symlink Emacs.app to application folder (isn't supported by spotlight).

#+BEGIN_SRC sh
brew linkapps emacs
#+END_SRC

Remove the symlink.

#+BEGIN_SRC sh
rm /Applications/Emacs.app
#+END_SRC

Create an alias for emacs and move it to the application folder, this is supported
by spotlight.

#+BEGIN_SRC sh
osascript -e 'tell application "Finder" to make alias file to POSIX file "/usr/local/opt/emacs/Emacs.app" at POSIX file "/Applications"'
#+END_SRC

* External Dependencies
** The Silver Searcher

The search functionality of some packages (dumb-jump and projectile) depends
on the silver search for speed.

#+BEGIN_SRC sh
brew install the_silver_searcher
#+END_SRC

** Aspell

Spellcheck depends on aspell.

#+BEGIN_SRC sh
brew install aspell
#+END_SRC

* Defaults
** Turn off alarms completly

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

** Answering 'y' or 'n'

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Keep all backup and auto-save files in one directory

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

#+END_SRC

** Kill current buffer rather than bringing up list

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC

** Warn when opening large files

Warn when opening files bigger than 100MB.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC

** Mode line settings

Add line and column number as well as file size to mode line.

#+BEGIN_SRC emacs-lisp
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC

** Use Utf-8 encoding

#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC

** Smooth scrolling

Make scrolling in buffers less jumpy.

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
    scroll-conservatively 100000
    scroll-preserve-screen-position 1)
#+END_SRC

** Truncate lines

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines t)
#+END_SRC

** Display Help in same window

#+BEGIN_SRC emacs-lisp
(add-to-list 'display-buffer-alist
       '("*Help*" display-buffer-same-window))
#+END_SRC

** Super save

[[https://github.com/bbatsov/super-save][Super-save]] auto-saves your buffers, when certain events happen - e.g. you
switch between buffers, an Emacs frame loses focus, etc.

#+BEGIN_SRC emacs-lisp
(use-package super-save
  :ensure t
  :config
  (super-save-mode +1))
#+END_SRC

* Appearance
** Menu, tool and scroll bars

Hide menu bar.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
#+END_SRC

Hide scroll and tool bar when not in terminal mode.

#+BEGIN_SRC emacs-lisp
(when (display-graphic-p)
  (scroll-bar-mode -1)
  (tool-bar-mode -1))
#+END_SRC

** Splash screen

Disables default splash screen.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t
    inhibit-startup-message t
    inhibit-startup-echo-area-message t)
#+END_SRC

** Theme
*** Spacemacs

[[https://github.com/nashamri/spacemacs-theme][Spacemacs-theme]] is a nice theme with both light/dark variants.

#+BEGIN_SRC emacs-lisp
(use-package spacemacs-theme
  :ensure t
  :defer t)
#+END_SRC

*** Set light/dark themes

Sets light/dark themes, and loads initial theme.

#+BEGIN_SRC emacs-lisp
(setq dark-theme 'spacemacs-dark)
(setq light-theme 'spacemacs-light)

(setq active-theme dark-theme)

(load-theme active-theme t)
#+END_SRC

*** Toggle light/dark

Function for toggling between light and dark themes.

#+BEGIN_SRC emacs-lisp

(defun toggle-dark-light-theme ()
  (interactive)
  (disable-theme active-theme)
  (if (eq active-theme light-theme)
    (setq active-theme dark-theme)
    (setq active-theme light-theme))
  (load-theme active-theme t))
#+END_SRC

** Initial frame
*** Size

Sets the initial frame to fill the height of the screen.

#+BEGIN_SRC emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . fullheight))
#+END_SRC

*** Position

Sets the initial frame to be flush with the top left corner of the screen.

#+BEGIN_SRC emasc-lisp
(add-to-list 'initial-frame-alist '(left . 0))
(add-to-list 'initial-frame-alist '(top . 0))
#+END_SRC

* Shell
** Exec path from shell

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] makes emacs shell behave like local shell.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
  :ensure t)
#+END_SRC

Sets $MANPATH, $PATH and exec-path from your shell, but only on OS X.
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize))
#+END_SRC

** Toggle Shell
If shell window is open close it otherwise open it.

#+BEGIN_SRC emacs-lisp
(defun toggle-shell ()
   "If shell window is open close it otherwise open it."
   (interactive)
   (if (get-buffer-window "*shell*")
    (delete-window (get-buffer-window "*shell*"))
  (shell)))
#+END_SRC

* Text Manipulation
** Delete selected region when typing

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Only use spaces

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** Tab width

Set tab width.

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
#+END_SRC

** Contextual tab

Tab will now contextually indent or complete.

#+BEGIN_SRC emacs-lisp
(setq tab-always-indent 'complete)
#+END_SRC

** Move Text

[[https://github.com/emacsfodder/move-text][MoveText]] is extracted from Basic edit toolkit. It allows you to move the
current line using M-up / M-down if a region is marked, it will move the
region instead.

#+BEGIN_SRC emacs-lisp
(use-package move-text
  :ensure t
  :init
  (move-text-default-bindings))
#+END_SRC

** Flyspell

Turn spellcheck on, sets it to use aspell and british spelling.

#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :config
  (setq ispell-program-name "aspell"
    ispell-extra-args '("--sug-mode=ultra" "--lang=en_GB"))
  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode))
#+END_SRC

** Expand Region

[[https://github.com/magnars/expand-region.el][Expand-region]]  increases the selected region by semantic units.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
       :ensure t)
#+END_SRC

** Undo tree

[[https://www.emacswiki.org/emacs/UndoTree][Undo-tree]] enables conventional undo-redo behaviour.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :bind (("s-Z" . undo-tree-redo)
     ("s-z" . undo-tree-undo))
  :config
  (setq undo-tree-history-directory-alist
    `((".*" . ,temporary-file-directory)))
  (setq undo-tree-auto-save-history t))
#+END_SRC

** White space

[[https://www.emacswiki.org/emacs/WhiteSpace][whitespace]] helps visualise white space.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :init
  (dolist (hook '(prog-mode-hook text-mode-hook))
    (add-hook hook #'whitespace-mode))
  (add-hook 'before-save-hook #'whitespace-cleanup)
  :config
  (setq whitespace-line-column 80) ;; limit line length
  (setq whitespace-style '(face tabs empty trailing lines-tail)))
#+END_SRC

* Navigation
** Recent files

[[https://www.emacswiki.org/emacs/RecentFiles][Recentf]] is a minor mode that builds a list of recently opened files.

#+BEGIN_SRC emacs-lisp
(recentf-mode t)
#+END_SRC

** Ivy

[[https://github.com/abo-abo/swiper][Ivy]] a light weight fuzzy search completion framework.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
       :ensure t
       :config
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       :init
       (ivy-mode t))
#+END_SRC

** Swiper

[[https://github.com/abo-abo/swiper][Swiper]] an Ivy-enhanced alternative to isearch.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind ("C-s" . swiper)
    ("s-f" . swiper))
#+END_SRC

** Projectile

[[https://github.com/bbatsov/projectile][Projectile]] is a project interaction library for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package projectile
     :ensure t
     :config
     (setq projectile-completion-system 'ivy)
     :init
     (projectile-global-mode))
#+END_SRC

You can discover projects in a folder with the command:

#+BEGIN_SRC
M-x projectile-discover-projects-in-directory
#+END_SRC

 Add custom project type and test suffix function.

#+BEGIN_SRC emacs-lisp

(projectile-register-project-type 'npm '("package.json" "src" "test") "npm start" "npm test")

(setq projectile-test-suffix-function 'custome-projectile-test-suffix)

(defun custome-projectile-test-suffix (project-type)
  "Find default test files suffix based on PROJECT-TYPE."
  (cond
   ((member project-type '(emacs-cask)) "-test")
   ((member project-type '(rails-rspec ruby-rspec npm)) "_spec")
   ((member project-type '(rails-test ruby-test lein-test boot-clj go elixir)) "_test")
))

#+END_SRC

** Dumb Jump

[[https://github.com/jacktasia/dumb-jump][Dumb Jump]] is an Emacs "jump to definition" package with support for multiple
programming languages that favors "just working". This means minimal -- and
ideally zero -- configuration with absolutely no stored indexes (TAGS) or
persistent background processes.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
   :ensure t
   :bind ("s-b" . dumb-jump-go)
   :config
   (setq dumb-jump-selector 'ivy))
#+END_SRC

** Hail Hydra

Once you summon the [[https://github.com/abo-abo/hydra][Hydra]] through the prefixed binding (the body +
any one head), all heads can be called in succession with only a
short extension.

The Hydra is vanquished once Hercules, any binding that isn't the
Hydra's head, arrives. Note that Hercules, besides vanquishing the
Hydra, will still serve his original purpose, calling his proper
command.

#+BEGIN_SRC emacs-lisp
(use-package hydra
       :ensure t)
#+END_SRC

Hail Hydra, a hydra for navigating emacs.

#+BEGIN_SRC emacs-lisp
(defhydra hail-hydra (:foreign-keys warn :columns 3)
  "Hail Hydra"
  ("b" hydra-buffer/body "buffer" :exit t)
  ("c" hydra-config/body "config" :exit t)
  ("f" hydra-file/body "file" :exit t)
  ("g" hydra-git/body "git" :exit t)
  ("h" hydra-help/body "help" :exit t)
  ("p" hydra-project/body "project" :exit t)
  ("s" toggle-shell "shell" :exit t)
  ("w" hydra-window/body "window" :exit t)
  ("+" toggle-dark-light-theme "light/dark" :exit t)
  ("q" nil "quit")
)
#+END_SRC

*** Buffer hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffer (:foreign-keys warn :columns 3)
  "Buffer"
  ("s" ivy-switch-buffer "switch" :exit t)
  ("n" next-buffer "next")
  ("p" previous-buffer "previous")
  ("k" kill-this-buffer "kill" :exit t)
  ("q" nil "quit")
)
#+END_SRC

*** Config hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-config (:foreign-keys warn :columns 3)
  "Config"
  ("o" (find-file  "~/.emacs.d/config.org") "open emacs config" :exit t)
  ("r" (load-file  "~/.emacs.d/init.el") "reload emacs config" :exit t)
  ("q" nil "quit")
)
#+END_SRC

*** File hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-file (:foreign-keys warn :columns 3)
  "File"
  ("o" find-file "open file" :exit t)
  ("r" ivy-switch-buffer "recent file" :exit t)
  ("s" swiper "search file" :exit t)
  ("q" nil "quit")
)
#+END_SRC

*** Git hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-git (:foreign-keys warn :columns 3)
  "Git"
  ("s" magit-status "status" :exit t)
  ("b" magit-blame "blame" :exit t)
  ("q" nil "quit")
)
#+END_SRC

*** Help hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-help (:foreign-keys warn :columns 3)
  "Help"
  ("f" describe-function "describe function" :exit t)
  ("k" describe-key "describe key" :exit t)
  ("m" describe-mode "describe mode" :exit t)
  ("v" describe-variable "describe variable" :exit t)
  ("q" nil "quit" :exit t)
)
#+END_SRC

*** Project hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-project (:foreign-keys warn :columns 3)
  "Project"
  ("o" projectile-switch-project "open project" :exit t)
  ("f" projectile-find-file "find file in project" :exit t)
  ("j" dumb-jump-go "jump to definition")
  ("r" dumb-jump-back "return from definition")
  ("s" projectile-ag "search project")
  ("t" projectile-toggle-between-implementation-and-test  "toggle test/implementation" :exit t)
  ("T" projectile-test-project "runs all tests" :exit t)
  ("q" nil "quit")
)
#+END_SRC

*** Window hydra

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window (:foreign-keys warn :columns 3)
  "Window"
  ("f" toggle-frame-fullscreen "toggle fullscreen" :exit t)
  ("h" split-window-below "horizontal split" :exit t)
  ("k" delete-window "kill window" :exit t)
  ("s" other-window "switch window")
  ("v" split-window-right "vertical split" :exit t)
  ("q" nil "quit")
)
#+END_SRC

** Key Chord

[[https://www.emacswiki.org/emacs/key-chord.el][Key-chord]] is a minor mode which allows you to bind commands to keys
that should be pressed together or consecutively (with little time
between the keystrokes - by default 0.3 seconds).

#+BEGIN_SRC emacs-lisp
(use-package key-chord
       :ensure t
       :config
       (key-chord-define-global "hh" 'hail-hydra/body)
       (key-chord-mode t))
#+END_SRC

** Ag (Silver Searcher)

[[https://github.com/Wilfred/ag.el][Ag]] allows you to search using ag from inside Emacs. You can filter
by file type, edit results inline, or find files.

#+BEGIN_SRC emacs-lisp
(use-package ag
  :ensure t)
#+END_SRC

* Project Management
** Magit

[[https://magit.vc/][Magit]] is a great interface for git projects.

#+BEGIN_SRC emacs-lisp
  (use-package magit
       :ensure t
       :defer t
       :bind (("C-c g s" . magit-status)
        ("C-c g b" . magit-blame))
       :config
       (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
       (setq magit-completing-read-function 'ivy-completing-read))
#+END_SRC

*** Fullscreen magit

The following code makes magit-status run alone in the frame, and then
restores the old window configuration when you quit out of magit.

#+BEGIN_SRC emacs-lisp
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+END_SRC

** Org mode
*** Org babel/source blocks
Enables source blocks syntax highlights and makes the editing popup
window stay within the same window.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t
  org-src-window-setup 'current-window
  org-src-strip-leading-and-trailing-blank-lines t
  org-src-preserve-indentation t
  org-src-tab-acts-natively t)
#+END_SRC

* Programming Languages
** General
*** Show line numbers

#+BEGIN_SRC emacs-lisp
 (add-hook 'prog-mode-hook (lambda () (linum-mode t)))
#+END_SRC

*** Electric pair mode

Automatically pair parens, brackets, quotes, etc...

#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC

*** Show paren mode

Show matching Parens.

#+BEGIN_SRC emacs-lisp
(show-paren-mode t)
#+END_SRC

*** Company mode

[[https://github.com/company-mode/company-mode][Company]] is a text completion framework for Emacs. The name stands
for "complete anything". It uses pluggable back-ends and front-ends
to retrieve and display completion candidates.

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (global-company-mode))
#+END_SRC

*** YASnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function templates.

Snippets are stored in the /.emacs.d/snippets/ directory in directories
that match the mode they should be available in.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (setq yas-snippet-dirs (concat user-emacs-directory "snippets"))
  (yas-global-mode))
#+END_SRC

*** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] on-the-fly syntax checking extension.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC

*** Comment/uncomment a line/region

Binds a key to comment/uncomment a line or region if selected.

#+BEGIN_SRC emacs-lisp
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line
   if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
      (setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))

(global-set-key (kbd "s-/") 'comment-or-uncomment-region-or-line)
#+END_SRC

*** Compilation buffers display ANSI

#+BEGIN_SRC emacs-lisp
(ignore-errors
  (require 'ansi-color)
  (defun colorize-compilation-buffer ()
  (when (eq major-mode 'compilation-mode)
    (ansi-color-apply-on-region compilation-filter-start (point-max))))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer))
#+END_SRC

** Lisps
*** Parinfer
[[https://github.com/DogLooksGood/parinfer-mode/blob/master/README.org][Parinfer]] infers lisp parentheses based on indentation.

#+BEGIN_SRC emacs-lisp
  (use-package parinfer
  :ensure t
  :bind
  (("C-," . parinfer-toggle-mode))
  :init
  (progn
    (setq parinfer-extensions
    '(defaults
      pretty-parens
      paredit
      smart-tab
      smart-yank))
    (add-hook 'clojure-mode-hook #'parinfer-mode)
    (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
    (add-hook 'common-lisp-mode-hook #'parinfer-mode)
    (add-hook 'scheme-mode-hook #'parinfer-mode)
    (add-hook 'lisp-mode-hook #'parinfer-mode)))
#+END_SRC

** Ruby
*** Other files that should be treated as ruby code

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist
     '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
(add-to-list 'auto-mode-alist
     '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))
#+END_SRC

*** Flycheck

Flycheck checks Ruby with ruby-rubocop and ruby-rubylint, falling back to
ruby or ruby-jruby for basic syntax checking if those are not available.

** Javascript
*** Web mode
Handles files that mix html and js like jsx.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :config
  (web-mode-use-tabs))
#+END_SRC

*** Other files that should be treated as javascript code

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode))
#+END_SRC

*** Flycheck

Flycheck checks Javascript with one of javascript-eslint, javascript-jshint
or javascript-gjslint, and then with javascript-jscs.

** Json
*** Json mode

[[Major mode for editing JSON file][Json Mode]] is a major mode for editing JSON file.

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t)
#+END_SRC

*** Flycheck

Flycheck checks JSON with json-jsonlint or json-python-json.
